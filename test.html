<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Spin Structure</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <!-- OrbitControls (同じバージョンの three/examples から) -->
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.min.js"></script>

  <script>
    // シーンとカメラ設定
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 8;

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // スピン情報保持用
    const spinGroup = new THREE.Group();
    scene.add(spinGroup);

    const spinData = [];
    const layers = 3;
    const spinsPerLayer = 12;
    const layerSpacing = 1.5;

    for (let layer = 1; layer <= layers; layer++) {
      const radius = layer * layerSpacing;

      for (let i = 0; i < spinsPerLayer; i++) {
        const theta = Math.acos(2 * Math.random() - 1);
        const phi = 2 * Math.PI * Math.random();

        const x = radius * Math.sin(theta) * Math.cos(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(theta);

        const origin = new THREE.Vector3(0, 0, 0);
        const direction = new THREE.Vector3(x, y, z).normalize();
        const length = 1 + Math.random(); // 振幅
        const colorPhase = Math.random() * 360;
        const hexColor = new THREE.Color(`hsl(${colorPhase}, 100%, 60%)`);

        const arrow = new THREE.ArrowHelper(direction, origin, length, hexColor.getHex(), 0.2, 0.1);
        spinGroup.add(arrow);

        spinData.push({
          object: arrow,
          axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(),
          speed: 0.01 + Math.random() * 0.02
        });
      }
    }

    // 透明な球体
    const geometry = new THREE.SphereGeometry(layerSpacing * layers, 32, 32);
    const material = new THREE.MeshBasicMaterial({
      color: 0x8888ff,
      wireframe: true,
      transparent: true,
      opacity: 0.1
    });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // アニメーション
    function animate() {
      requestAnimationFrame(animate);
      spinData.forEach(spin => {
        spin.object.setDirection(
          spin.object.getDirection().clone().applyAxisAngle(spin.axis, spin.speed)
        );
      });
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // リサイズ対応
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
